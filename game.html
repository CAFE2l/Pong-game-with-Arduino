<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gira Pong</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Gira Pong</h1>
        
        <div class="main-content">
            <div class="game-area">
                <canvas id="gameCanvas" width="1000" height="600"></canvas>
                 <div class="score-board">
                     <div class="score">
                         <div class="score-label">JOGADOR 1</div> <div id="playerScore" class="score-value">0</div>
                     </div>
                     <div class="score">
                         <div id="cpuScoreLabel" class="score-label">CPU</div> 
                         <div id="cpuScore" class="score-value">0</div>
                     </div>
                 </div>
            </div>

            <div class="panel">
                <div class="panel-section">
                    <h2>CONEXÃO</h2>
                    <div class="status-box">
                        <span id="statusTextP1">P1: Desconectado</span>
                        <div id="statusIndicatorP1" class="status-indicator status-disconnected"></div>
                    </div>
                    <button id="connectBtnP1">CONECTAR JOGADOR 1</button>
                    
                    <div class="status-box" style="margin-top: 10px;">
                        <span id="statusTextP2">P2: Desconectado</span>
                        <div id="statusIndicatorP2" class="status-indicator status-disconnected"></div>
                    </div>
                    <button id="connectBtnP2">CONECTAR JOGADOR 2</button>
                    </div>

                <div class="panel-section">
                    <h2>JOGO</h2>
                    <div class="mode-select">
                        <button id="modeCpuBtn" class="mode-btn active">1 VS CPU</button>
                        <button id="modeP2Btn" class="mode-btn">1 VS 1</button>
                    </div>
                    <button id="startBtn">INICIAR JOGO</button>
                    <button id="pauseBtn" disabled>PAUSAR</button>
                    <button id="resetBtn">NOVO JOGO</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PongGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

       
                // --- CONSTANTES DO JOGO ---
                this.PADDLE_WIDTH = 15;
                this.PADDLE_HEIGHT = 130;
                this.BALL_RADIUS = 10;
                this.WINNING_SCORE = 3;
                this.PADDLE_SMOOTHING = 0.12; // <-- DEIXEI MAIS LENTO (original 0.18)
                this.INITIAL_BALL_SPEED = 7; // <-- BOLA MAIS LENTA (original 9)
                this.BALL_ACCELERATION = 1.06; // <-- ACELERAÇÃO MENOR (original 1.08)

                // --- ESTADO DO JOGO ---
                this.hitCounter = 0; // NOVO: Contador de rebatidas
                this.playerY = (this.canvas.height - this.PADDLE_HEIGHT) / 2;
                this.playerTargetY = this.playerY; 
                this.cpuY = (this.canvas.height - this.PADDLE_HEIGHT) / 2;
                this.cpuTargetY = this.cpuY; 
                this.playerScore = 0;
                this.cpuScore = 0;
                this.gameRunning = false;
                this.isPaused = false;
                this.gameOver = false;
                this.winnerText = '';
                this.gameMode = 'cpu';
                
                this.ballX = 0;
                this.ballY = 0;
                this.ballSpeedX = 0;
                this.ballSpeedY = 0;

                // --- ### INÍCIO DAS MUDANÇAS NO JS (CONEXÃO) ### ---
                this.portP1 = null;
                this.readerP1 = null;
                this.portP2 = null;
                this.readerP2 = null;

                this.isCalibrating = false; // Apenas P1 calibra
                this.potMin = 1023;
                this.potMax = 0;
                // --- FIM DAS MUDANÇAS NO JS (CONEXÃO) ---

                // --- ELEMENTOS DA UI ---
                this.ui = {
                    // --- MUDANÇA: Botões de conexão P1 e P2 ---
                    connectBtnP1: document.getElementById('connectBtnP1'),
                    connectBtnP2: document.getElementById('connectBtnP2'),
                    statusTextP1: document.getElementById('statusTextP1'),
                    statusIndicatorP1: document.getElementById('statusIndicatorP1'),
                    statusTextP2: document.getElementById('statusTextP2'),
                    statusIndicatorP2: document.getElementById('statusIndicatorP2'),
                    // --- Fim da mudança ---
                    
                    startBtn: document.getElementById('startBtn'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    resetBtn: document.getElementById('resetBtn'),
                    playerScoreDisplay: document.getElementById('playerScore'),
                    cpuScoreDisplay: document.getElementById('cpuScore'),
                    modeCpuBtn: document.getElementById('modeCpuBtn'),
                    modeP2Btn: document.getElementById('modeP2Btn'),
                    cpuScoreLabel: document.getElementById('cpuScoreLabel'),
                };

                this.init();
            }

            init() {
                this.initEventListeners();
                this.resetBall(true);
                this.gameLoop();
            }

            initEventListeners() {
                // --- MUDANÇA: Listeners de conexão P1 e P2 ---
                this.ui.connectBtnP1.addEventListener('click', () => this.toggleArduinoConnection(1));
                this.ui.connectBtnP2.addEventListener('click', () => this.toggleArduinoConnection(2));
                // --- Fim da mudança ---

                this.ui.startBtn.addEventListener('click', () => this.startGame());
                this.ui.pauseBtn.addEventListener('click', () => this.togglePause());
                this.ui.resetBtn.addEventListener('click', () => this.resetGame());
                
                this.ui.modeCpuBtn.addEventListener('click', () => this.setGameMode('cpu'));
                this.ui.modeP2Btn.addEventListener('click', () => this.setGameMode('player2'));

                // Mouse SÓ controla o P2 se o modo for 'player2' E o Arduino P2 não estiver conectado
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMovement(e));
            }

            // --- LÓGICA DO JOGO (Sem grandes mudanças aqui) ---
            
            setGameMode(mode) {
                if (this.gameRunning) return; 

                this.gameMode = mode;
                if (mode === 'cpu') {
                    this.ui.modeCpuBtn.classList.add('active');
                    this.ui.modeP2Btn.classList.remove('active');
                    this.ui.cpuScoreLabel.textContent = 'CPU';
                } else { // modo 'player2'
                    this.ui.modeCpuBtn.classList.remove('active');
                    this.ui.modeP2Btn.classList.add('active');
                    this.ui.cpuScoreLabel.textContent = 'JOGADOR 2';
                }
                this.resetGame(); 
            }

            handleMouseMovement(event) {
                // Só controla o P2 se: modo 1v1 E Arduino P2 NÃO conectado
                if (this.gameMode !== 'player2' || this.portP2) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleY = this.canvas.height / rect.height;
                const mouseY = (event.clientY - rect.top) * scaleY;
                this.cpuTargetY = mouseY - this.PADDLE_HEIGHT / 2;
            }

            startGame() {
                if (this.gameRunning || this.gameOver) return;
                this.gameRunning = true;
                this.isPaused = false;
                this.ui.pauseBtn.disabled = false;
                this.ui.pauseBtn.textContent = 'PAUSAR';
                this.ui.modeCpuBtn.disabled = true; 
                this.ui.modeP2Btn.disabled = true;
                this.resetBall();
            }
            
            togglePause() {
                if (!this.gameRunning || this.gameOver) return;
                this.isPaused = !this.isPaused;
                this.ui.pauseBtn.textContent = this.isPaused ? 'RETOMAR' : 'PAUSAR';
            }

            resetGame() {
                this.playerScore = 0;
                this.cpuScore = 0;
                this.updateScoreDisplay();
                this.gameRunning = false;
                this.isPaused = false;
                this.gameOver = false;
                this.winnerText = '';
                this.ui.pauseBtn.disabled = true;
                this.ui.pauseBtn.textContent = 'PAUSAR';
                this.ui.modeCpuBtn.disabled = false; 
                this.ui.modeP2Btn.disabled = false;
                this.hitCounter = 0; // <-- ADICIONE ESTA LINHA
                this.playerY = (this.canvas.height - this.PADDLE_HEIGHT) / 2;
                this.playerTargetY = this.playerY; 
                this.cpuY = (this.canvas.height - this.PADDLE_HEIGHT) / 2;
                this.cpuTargetY = this.cpuY; 

                this.resetBall(true);
            }

            endGame(winner) {
                this.gameOver = true;
                this.gameRunning = false;
                
                let winnerName = winner;
                if (winner === 'CPU' && this.gameMode === 'player2') {
                    winnerName = 'JOGADOR 2';
                }

                this.winnerText = `${winnerName} VENCEU!`;
                this.ui.pauseBtn.disabled = true;
                this.ui.modeCpuBtn.disabled = false;
                this.ui.modeP2Btn.disabled = false;
            }

            resetBall(shouldStop = false) {
                this.ballX = this.canvas.width / 2;
                this.ballY = this.canvas.height / 2;
                if (shouldStop) {
                    this.ballSpeedX = 0;
                    this.ballSpeedY = 0;
                } else {
                    this.ballSpeedX = (Math.random() > 0.5 ? 1 : -1) * this.INITIAL_BALL_SPEED;
                    this.ballSpeedY = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 3 + 2);
                }
            }

            updateScoreDisplay() {
                this.ui.playerScoreDisplay.textContent = this.playerScore;
                this.ui.cpuScoreDisplay.textContent = this.cpuScore;
            }

            // --- ### INÍCIO DA REESTRUTURAÇÃO DA CONEXÃO ### ---
            
            async toggleArduinoConnection(playerNum) {
                const port = (playerNum === 1) ? this.portP1 : this.portP2;
                
                if (port) {
                    await this.disconnectArduino(playerNum);
                } else {
                    await this.connectArduino(playerNum);
                }
            }

            async connectArduino(playerNum) {
                if (!navigator.serial) {
                    alert("A Web Serial API não é suportada neste navegador. Use Google Chrome ou Edge.");
                    return;
                }
                
                try {
                    // P1 faz calibração, P2 apenas conecta
                    if (playerNum === 1) {
                        this.updateStatus(1, 'Calibrando...', 'status-calibrating');
                    } else {
                        this.updateStatus(2, 'Conectando...', 'status-calibrating');
                    }
                    
                    const port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 9600 });

                    if (playerNum === 1) {
                        this.portP1 = port;
                        this.startCalibration(); // Inicia calibração (apenas P1)
                    } else {
                        this.portP2 = port;
                        this.updateStatus(2, 'Conectado', 'status-connected');
                        this.ui.connectBtnP2.textContent = 'DESCONECTAR P2';
                    }
                    
                    this.startReading(playerNum); // Inicia leitura para o jogador
                    
                } catch (error) {
                    console.error(`Erro ao conectar P${playerNum}:`, error);
                    this.updateStatus(playerNum, 'Erro', 'status-disconnected');
                }
            }

            async disconnectArduino(playerNum) {
                let port = null;
                let reader = null;

                if (playerNum === 1) {
                    port = this.portP1;
                    reader = this.readerP1;
                } else {
                    port = this.portP2;
                    reader = this.readerP2;
                }

                if (reader) await reader.cancel();
                if (port) await port.close();
                
                if (playerNum === 1) {
                    this.portP1 = null;
                    this.readerP1 = null;
                    this.updateStatus(1, 'P1: Desconectado', 'status-disconnected');
                    this.ui.connectBtnP1.textContent = 'CONECTAR JOGADOR 1';
                } else {
                    this.portP2 = null;
                    this.readerP2 = null;
                    this.updateStatus(2, 'P2: Desconectado', 'status-disconnected');
                    this.ui.connectBtnP2.textContent = 'CONECTAR JOGADOR 2';
                }
            }
              startCalibration() {
                this.isCalibrating = true;
                this.potMin = 1023; 
                this.potMax = 0;
                this.updateStatus(1, 'Calibrando P1... Gire!', 'status-calibrating');
                this.playerY = (this.canvas.height - this.PADDLE_HEIGHT) / 2;
                this.playerTargetY = this.playerY;

                setTimeout(() => {
                    this.isCalibrating = false;
                    
                    // ### MUDANÇA: LOG DE DEBUG ###
                    console.log(`Calibração terminada. Min detectado: ${this.potMin}, Max detectado: ${this.potMax}`);
                    // ### FIM DA MUDANÇA ###

                    if ((this.potMax - this.potMin) < 50) { 
                        this.potMin = 0; this.potMax = 1023;
                        console.log('CALIBRAÇÃO P1 FALHOU! Usando valores padrão (0-1023). Este é o problema!');
                    } else {
                        console.log(`Calibração P1 SUCESSO. Usando range [${this.potMin}, ${this.potMax}]`);
                    }
                    this.updateStatus(1, 'P1: Conectado', 'status-connected');
                    this.ui.connectBtnP1.textContent = 'DESCONECTAR P1';
                }, 5000); 
            }

            async startReading(playerNum) {
                const decoder = new TextDecoder();
                let port = (playerNum === 1) ? this.portP1 : this.portP2;
                
                while (port?.readable) {
                    let reader = port.readable.getReader();
                    
                    if(playerNum === 1) this.readerP1 = reader;
                    else this.readerP2 = reader;

                    try {
                        let partialData = ''; 
                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) break;
                            
                            partialData += decoder.decode(value, { stream: true });
                            
                            let newlineIndex;
                            while ((newlineIndex = partialData.indexOf('\n')) !== -1) {
                                const line = partialData.substring(0, newlineIndex).trim();
                                partialData = partialData.substring(newlineIndex + 1);
                                
                                if (line) {
                                    this.processArduinoData(line);
                                }
                            }
                        }
                    } catch (error) {
                        // Ignora erros (como desconexão)
                    } finally {
                        reader.releaseLock();
                    }
                }
            }

           processArduinoData(line) {
                if (line.startsWith('P1:')) {
                    const potValue = parseInt(line.substring(3));
                    if (isNaN(potValue)) return;

                    if (this.isCalibrating) {
                        if (potValue < this.potMin) this.potMin = potValue;
                        if (potValue > this.potMax) this.potMax = potValue;
                    } else {
                        // ### MUDANÇA: LOG DE DEBUG ###
                        if (Math.random() < 0.05) { // Loga 5% das vezes (para não poluir)
                            console.log(`P1 lendo: ${potValue} | Range: [${this.potMin}, ${this.potMax}]`);
                        }
                        // ### FIM DA MUDANÇA ###

                        const paddleMaxY = this.canvas.height - this.PADDLE_HEIGHT;
                        this.playerTargetY = this.mapValue(potValue, this.potMin, this.potMax, 0, paddleMaxY);
                    }
                }
                
                // Lógica para P2
                else if (line.startsWith('P2:')) {
                    const potValue = parseInt(line.substring(3));
                    if (isNaN(potValue)) return;
                    if (!this.isCalibrating) {
                         const paddleMaxY = this.canvas.height - this.PADDLE_HEIGHT;
                        this.cpuTargetY = this.mapValue(potValue, this.potMin, this.potMax, 0, paddleMaxY);
                    }
                }
                
                // Botão de P1 controla o jogo
                else if (line === 'BTN:1') {
                    if (this.gameOver) this.resetGame();
                    else if (!this.gameRunning) this.startGame();
                }
            }

            mapValue(value, inMin, inMax, outMin, outMax) {
                const divisor = inMax - inMin;
                if (divisor === 0) {
                    return (outMin + outMax) / 2; 
                }
                const mappedValue = (value - inMin) * (outMax - outMin) / divisor + outMin;
                return Math.max(outMin, Math.min(mappedValue, outMax));
            }
            
            updateStatus(playerNum, message, cssClass) {
                if (playerNum === 1) {
                    this.ui.statusTextP1.textContent = `P1: ${message}`;
                    this.ui.statusIndicatorP1.className = `status-indicator ${cssClass}`;
                } else {
                    this.ui.statusTextP2.textContent = `P2: ${message}`;
                    this.ui.statusIndicatorP2.className = `status-indicator ${cssClass}`;
                }
            }
            // --- ### FIM DA REESTRUTURAÇÃO DA CONEXÃO ### ---


            // --- LOOP PRINCIPAL DO JOGO ---
            update() {
                if (this.isPaused || this.gameOver) return;

                // --- MOVIMENTO RAQUETE JOGADOR 1 (ARDUINO P1) ---
                let distance = this.playerTargetY - this.playerY;
                if (Math.abs(distance) < 1) { 
                    this.playerY = this.playerTargetY;
                } else {
                    this.playerY += distance * this.PADDLE_SMOOTHING;
                }
                this.playerY = Math.max(0, Math.min(this.canvas.height - this.PADDLE_HEIGHT, this.playerY));


                if (!this.gameRunning) return;

                // --- MOVIMENTO DA BOLA ---
                this.ballX += this.ballSpeedX;
                this.ballY += this.ballSpeedY;

                // --- COLISÃO COM PAREDES (CIMA/BAIXO) ---
                if (this.ballY - this.BALL_RADIUS < 0) {
                    this.ballY = this.BALL_RADIUS;
                    this.ballSpeedY = -this.ballSpeedY;
                } else if (this.ballY + this.BALL_RADIUS > this.canvas.height) {
                    this.ballY = this.canvas.height - this.BALL_RADIUS;
                    this.ballSpeedY = -this.ballSpeedY;
                }

                // --- VERIFICA PONTUAÇÃO ---
                if (this.ballX - this.BALL_RADIUS < 0) {
                    this.cpuScore++; 
                    this.updateScoreDisplay();
                    if (this.cpuScore >= this.WINNING_SCORE) {
                        this.endGame(this.gameMode === 'cpu' ? 'CPU' : 'JOGADOR 2');
                    } else {
                        this.resetBall();
                    }
                    return;
                }
                if (this.ballX + this.BALL_RADIUS > this.canvas.width) {
                    this.playerScore++; 
                    this.updateScoreDisplay();
                    if (this.playerScore >= this.WINNING_SCORE) {
                        this.endGame('JOGADOR 1');
                    } else {
                        this.resetBall();
                    }
                    return;
                }
// --- LÓGICA DE COLISÃO COM AS RAQUETES ---
                let hitRegistered = false;

                // Colisão com Jogador 1 (Esquerda)
                if (this.ballX - this.BALL_RADIUS <= this.PADDLE_WIDTH &&
                    this.ballSpeedX < 0 &&
                    this.ballY + this.BALL_RADIUS > this.playerY &&
                    this.ballY - this.BALL_RADIUS < this.playerY + this.PADDLE_HEIGHT) 
                {
                    this.ballX = this.PADDLE_WIDTH + this.BALL_RADIUS; // Corrige posição
                    hitRegistered = true;
                }
                
                // Colisão com Jogador 2 (Direita)
                else if (this.ballX + this.BALL_RADIUS >= this.canvas.width - this.PADDLE_WIDTH &&
                    this.ballSpeedX > 0 &&
                    this.ballY + this.BALL_RADIUS > this.cpuY &&
                    this.ballY - this.BALL_RADIUS < this.cpuY + this.PADDLE_HEIGHT) 
                {
                    this.ballX = this.canvas.width - this.PADDLE_WIDTH - this.BALL_RADIUS; // Corrige posição
                    hitRegistered = true;
                }

                // Lógica de aceleração (SÓ SE HOUVE REBATIDA)
                if (hitRegistered) {
                    this.hitCounter++; // 1. Incrementa o contador
                    
                    let speedMultiplier = 1.0; // 2. Por padrão, não acelera
                    
                    // 3. Se for a 2ª, 4ª, 6ª rebatida...
                    if (this.hitCounter % 2 === 0) {
                        speedMultiplier = this.BALL_ACCELERATION; // Aplica aceleração
                    }

                    // 4. Inverte a velocidade e aplica o multiplicador
                    this.ballSpeedX = -this.ballSpeedX * speedMultiplier;
                }

                // --- IA DA CPU / CONTROLE JOGADOR 2 ---
                if (this.gameMode === 'cpu') {
                    // MODO 1 VS CPU: Usa a IA
                    const cpuCenter = this.cpuY + this.PADDLE_HEIGHT / 2;
                    const deadZone = 10;
                    const cpuSpeed = 5.5; 
                    if (cpuCenter < this.ballY - deadZone) this.cpuY += cpuSpeed;
                    else if (cpuCenter > this.ballY + deadZone) this.cpuY -= cpuSpeed;

                } else { // MODO 1 VS 1
                    // Se P2 (Arduino 2) não estiver conectado, o mouse (handleMouseMovement) controla.
                    // Se P2 (Arduino 2) ESTIVER conectado, processArduinoData controla.
                    // Em ambos os casos, a variável cpuTargetY é atualizada,
                    // e a lógica de suavização abaixo move a raquete.
                    
                    distance = this.cpuTargetY - this.cpuY;
                    if (Math.abs(distance) < 1) {
                        this.cpuY = this.cpuTargetY;
                    } else {
                        this.cpuY += distance * this.PADDLE_SMOOTHING;
                    }
                }
                // Trava a raquete direita (CPU ou P2) dentro da tela
                this.cpuY = Math.max(0, Math.min(this.canvas.height - this.PADDLE_HEIGHT, this.cpuY));
            }

          // ### INÍCIO DAS MUDANÇAS DE RENDERIZAÇÃO ###
           // ### INÍCIO DAS MUDANÇAS DE RENDERIZAÇÃO ###
         // ### INÍCIO DAS MUDANÇAS DE RENDERIZAÇÃO ###
            draw() {
                // 1. FUNDO TRANSPARENTE COM EFEITO DE RASTRO (MOTION BLUR)
                this.ctx.fillStyle = 'rgba(0, 119, 190, 0.25)'; // Cor de água (#0077BE)
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);


                // 2. DESENHA A "REDE"
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Rede branca semi-transparente
                this.ctx.lineWidth = 5;
                this.ctx.setLineDash([10, 15]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.canvas.width / 2, 0);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);


                // 3. RAQUETES (COM BORDAS BRANCAS)
                this.ctx.lineWidth = 2; // Largura da borda para ambas as raquetes

                // Raquete Jogador 1 (Arduino)
                this.ctx.fillStyle = '#00ffff'; // Cor Ciano
                this.ctx.fillRect(0, this.playerY, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);
                this.ctx.strokeStyle = '#FFFFFF'; // Borda branca
                this.ctx.strokeRect(0, this.playerY, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);
                
                // Raquete Direita (CPU ou P2)
                this.ctx.fillStyle = (this.gameMode === 'cpu') ? '#ff00ff' : '#00ff00'; // Cor Magenta ou Verde
                this.ctx.fillRect(this.canvas.width - this.PADDLE_WIDTH, this.cpuY, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);
                this.ctx.strokeStyle = '#FFFFFF'; // Borda branca
                this.ctx.strokeRect(this.canvas.width - this.PADDLE_WIDTH, this.cpuY, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);

                
                // 4. BOLA (LARANJA NORMAL)
                if (this.gameRunning || this.gameOver) {
                    this.ctx.fillStyle = '#ff8c00'; // <-- COR LARANJA!
                    this.ctx.beginPath();
                    this.ctx.arc(this.ballX, this.ballY, this.BALL_RADIUS, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // ### EFEITO DE BRILHO REMOVIDO ###
                }
                
                // 5. TEXTOS (PONTUAÇÃO, PAUSE, ETC)
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                this.ctx.textAlign = 'center';

                if (this.gameOver) {
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.font = '40px "Press Start 2P"';
                    this.ctx.fillText(this.winnerText, centerX, centerY);
                    this.ctx.font = '20px "Press Start 2P"';
                    this.ctx.fillText('APERTE "NOVO JOGO"', centerX, centerY + 50);
                } else if (!this.gameRunning) {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '24px "Press Start 2P"';
                    this.ctx.fillText('APERTE INICIAR', centerX, centerY);
                } else if (this.isPaused) {
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = '40px "Press Start 2P"';
                    this.ctx.fillText('PAUSADO', centerX, centerY);
                }
            }
            // ### FIM DAS MUDANÇAS DE RENDERIZAÇÃO ###
            // ### FIM DAS MUDANÇAS DE RENDERIZAÇÃO ###
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new PongGame('gameCanvas');
        });
    </script>
</body>
</html>